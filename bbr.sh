#!/bin/bash

# ========================
# 常量定义
# ========================
declare -A SYSCTL_SETTINGS=(
    ["net.ipv4.tcp_rmem"]="4096 87380 6291456"
    ["net.ipv4.tcp_wmem"]="4096 87380 6291456"
    ["net.core.rmem_max"]=16777216
    ["net.core.wmem_max"]=16777216
    ["net.ipv4.tcp_fin_timeout"]=30
    ["net.ipv4.tcp_tw_reuse"]=1
    ["net.ipv4.tcp_window_scaling"]=1
    ["net.core.default_qdisc"]="fq"
    ["net.ipv4.tcp_congestion_control"]="bbr"
)

CONFIG_FILE="/etc/sysctl.d/99-bbr.conf"
MODULES=("tcp_bbr")

# ========================
# 工具函数
# ========================
die() {
    printf "\033[31m错误：%s\033[0m\n" "$*" >&2
    exit 1
}

check_command() {
    if ! command -v "$1" >/dev/null 2>&1; then
        die "未找到必需命令：$1 (可尝试安装包: ${2:-unknown})"
    fi
}

check_root() {
    [ "$(id -u)" -eq 0 ] || die "该脚本必须以 root 用户运行"
}

validate_setting() {
    local key=$1
    local expected=$2
    local actual
    actual=$(sysctl -n "$key" 2>/dev/null | xargs)
    expected=$(echo "$expected" | xargs)

    if [ "$actual" != "$expected" ]; then
        die "$key 设置失败 (当前值: '${actual}', 期望值: '${expected}')"
    fi
}

# ========================
# 主逻辑
# ========================
main() {
    # 预处理：移除Windows换行符
    sed -i 's/\r$//' "$0"

    # 预检条件验证
    check_root
    check_command sysctl procps
    check_command modprobe kmod
    check_command grep grep

    # 内核版本检查（BBR需要≥4.9）
    local kernel_ver
    kernel_ver=$(uname -r | awk -F. '{ printf("%d%02d", $1,$2) }')
    [ "$kernel_ver" -ge 409 ] || die "需要内核版本≥4.9 (当前: $(uname -r))"

    # 加载必要内核模块
    for module in "${MODULES[@]}"; do
        if ! grep -qw "^${module}" /proc/modules; then
            echo "加载内核模块: ${module}..."
            if ! modprobe "$module" 2>/dev/null; then
                echo "警告：无法加载模块 ${module}，可能已内置到内核中"
            fi
        fi
    done

    # 批量设置并验证sysctl参数
    for key in "${!SYSCTL_SETTINGS[@]}"; do
        sysctl -w "$key=${SYSCTL_SETTINGS[$key]}" >/dev/null
        validate_setting "$key" "${SYSCTL_SETTINGS[$key]}"
    done

    # 持久化所有配置（带备份机制）
    if [ -f "$CONFIG_FILE" ]; then
        cp -v "$CONFIG_FILE" "${CONFIG_FILE}.bak-$(date +%s)"
    fi
    {
        echo "# Generated by $(basename "$0") at $(date)"
        for key in "${!SYSCTL_SETTINGS[@]}"; do
            echo "${key}=${SYSCTL_SETTINGS[$key]}"
        done
    } > "$CONFIG_FILE"
    chmod 644 "$CONFIG_FILE"

    # 应用持久化配置
    if ! sysctl -p "$CONFIG_FILE"; then
        die "持久化配置应用失败，请检查 ${CONFIG_FILE} 文件内容"
    fi

    # 重启systemd-sysctl服务以确保生效
    if systemctl is-active systemd-sysctl >/dev/null 2>&1; then
        systemctl restart systemd-sysctl
    fi

    # 最终验证
    printf "\n\033[32m所有设置已成功应用！当前关键参数：\033[0m\n"
    sysctl -a 2>/dev/null | grep -E \
        'net.ipv4.tcp_(rmem|wmem|fin_timeout|tw_reuse|window_scaling)|net.core.(rmem_max|wmem_max|default_qdisc)|tcp_congestion_control'
}

main "$@"
